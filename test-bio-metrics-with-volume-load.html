<!DOCTYPE html>
<html lang="fr">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>STATS DASHBOARD - Hybrid Master 63</title>
    <link href="https://fonts.googleapis.com/css2?family=Orbitron:wght@400;700;900&display=swap" rel="stylesheet">
    <link href="https://fonts.googleapis.com/css2?family=Rajdhani:wght@400;500;600;700;900&display=swap" rel="stylesheet">
    
    <!-- CSS COMMUN (effets cockpit r√©utilisables) -->
    <link rel="stylesheet" href="css/chart-base-common.css">
    
    <!-- CSS SP√âCIFIQUES -->
    <link rel="stylesheet" href="css/bio-metrics-specific.css">
    <link rel="stylesheet" href="css/volume-load-specific.css">
    
    <style>
        body {
            margin: 0;
            padding: 40px 20px;
            background: #0a0a0a;
            font-family: 'Orbitron', sans-serif;
            min-height: 100vh;
        }
        
        .page-header {
            text-align: center;
            margin-bottom: 40px;
        }
        
        .page-title {
            font-size: 48px;
            font-weight: 900;
            background: linear-gradient(135deg, #22d3ee 0%, #8b5cf6 50%, #f97316 100%);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            background-clip: text;
            margin-bottom: 8px;
            letter-spacing: 3px;
        }
        
        .page-subtitle {
            font-size: 14px;
            color: rgba(255, 255, 255, 0.5);
            text-transform: uppercase;
            letter-spacing: 2px;
        }
        
        /* Grille des cartes stats */
        .stats-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(500px, 1fr));
            gap: 40px;
            max-width: 1400px;
            margin: 0 auto;
        }
        
        @media (max-width: 768px) {
            .stats-grid {
                grid-template-columns: 1fr;
                gap: 30px;
            }
        }
        
        /* Container VOLUME LOAD identique √† BIO-METRICS */
        #volumeLoadContainer {
            /* H√©rite du style chart-card-common */
        }
        
        /* Canvas VOLUME LOAD */
        .volume-gauge-wrapper {
            position: relative;
            width: 100%;
            aspect-ratio: 1 / 1;
            max-width: 500px;
            margin: 0 auto 24px;
        }
        
        #volumeGaugeCanvas {
            width: 100% !important;
            height: 100% !important;
        }
        
        /* Halos VOLUME LOAD */
        .volume-halo {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            border-radius: 50%;
            pointer-events: none;
        }
        
        .volume-halo-1 {
            width: 100%;
            height: 100%;
            background: radial-gradient(circle, rgba(34, 211, 238, 0.2) 0%, transparent 70%);
            animation: halo-pulse-volume-1 3s ease-in-out infinite;
        }
        
        .volume-halo-2 {
            width: 90%;
            height: 90%;
            background: radial-gradient(circle, rgba(139, 92, 246, 0.15) 0%, transparent 70%);
            animation: halo-pulse-volume-2 4s ease-in-out infinite 0.5s;
        }
        
        @keyframes halo-pulse-volume-1 {
            0%, 100% {
                transform: translate(-50%, -50%) scale(1);
                opacity: 0.6;
            }
            50% {
                transform: translate(-50%, -50%) scale(1.05);
                opacity: 0.8;
            }
        }
        
        @keyframes halo-pulse-volume-2 {
            0%, 100% {
                transform: translate(-50%, -50%) scale(1);
                opacity: 0.4;
            }
            50% {
                transform: translate(-50%, -50%) scale(1.08);
                opacity: 0.6;
            }
        }
        
        /* Footer stats VOLUME LOAD (r√©utilise le style de BIO-METRICS) */
        .volume-stats-footer {
            display: grid;
            grid-template-columns: repeat(2, 1fr);
            gap: 12px;
            margin-top: 24px;
        }
        
        .volume-stat-card {
            background: rgba(0, 0, 0, 0.4);
            border: 1px solid rgba(34, 211, 238, 0.2);
            border-radius: 8px;
            padding: 12px;
            text-align: center;
            transition: all 0.3s ease;
        }
        
        .volume-stat-card:hover {
            background: rgba(0, 0, 0, 0.6);
            border-color: rgba(34, 211, 238, 0.4);
            transform: translateY(-2px);
        }
        
        .volume-stat-label {
            font-size: 10px;
            font-weight: 700;
            color: rgba(255, 255, 255, 0.4);
            text-transform: uppercase;
            letter-spacing: 1px;
            margin-bottom: 4px;
        }
        
        .volume-stat-value {
            font-size: 20px;
            font-weight: 900;
            color: #22d3ee;
            font-family: 'Rajdhani', sans-serif;
        }
    </style>
</head>
<body>
    <div class="page-header">
        <h1 class="page-title">‚ö° STATS DASHBOARD</h1>
        <p class="page-subtitle">Premium Analytics - Hybrid Master 63</p>
    </div>
    
    <div class="stats-grid">
        <!-- CARTE 1 : BIO-METRICS RADAR -->
        <div id="bioContainer"></div>
        
        <!-- CARTE 2 : VOLUME LOAD GAUGE -->
        <div class="chart-card-common" id="volumeLoadContainer">
            <!-- Effets background cockpit -->
            <div class="chart-bg-effects">
                <div class="chart-scanline-anim"></div>
                <div class="chart-radial-glow"></div>
                <div class="chart-grid-pattern"></div>
            </div>
            
            <!-- Badge LIVE -->
            <div class="chart-badge-common">LIVE</div>
            
            <!-- Header -->
            <div class="chart-header-common">
                <h2 class="chart-title-common">VOLUME LOAD</h2>
                <p class="chart-subtitle-common">Weekly Training Volume</p>
            </div>
            
            <!-- Zone du graphique -->
            <div class="chart-zone-common">
                <div class="volume-gauge-wrapper">
                    <div class="volume-halo volume-halo-1"></div>
                    <div class="volume-halo volume-halo-2"></div>
                    <canvas id="volumeGaugeCanvas"></canvas>
                </div>
            </div>
            
            <!-- Footer stats -->
            <div class="chart-footer-common">
                <div class="volume-stats-footer">
                    <div class="volume-stat-card">
                        <div class="volume-stat-label">S√©ries</div>
                        <div class="volume-stat-value" id="volumeSets">0</div>
                    </div>
                    <div class="volume-stat-card">
                        <div class="volume-stat-label">TUT</div>
                        <div class="volume-stat-value" id="volumeTUT">0:00</div>
                    </div>
                    <div class="volume-stat-card">
                        <div class="volume-stat-label">Volume</div>
                        <div class="volume-stat-value" id="volumeTotal">0k kg</div>
                    </div>
                    <div class="volume-stat-card">
                        <div class="volume-stat-label">Statut</div>
                        <div class="volume-stat-value" id="volumeStatus">‚ö†Ô∏è AJUSTER</div>
                    </div>
                </div>
            </div>
        </div>
    </div>
    
    <script type="module">
        // ===== BIO-METRICS RADAR =====
        import BioMetricsRadar from './js/bio-metrics-standalone.js';
        
        const muscleData = [
            { id: 'pecs', name: 'PECS', normalized: 0.85, sets: 12, volume: 2101, intensity: 8.5, recovery: 45, type: 'primary' },
            { id: 'dos', name: 'DOS', normalized: 1.0, sets: 16, volume: 2341, intensity: 9.2, recovery: 80, type: 'primary' },
            { id: 'jambes', name: 'JAMBES', normalized: 0.55, sets: 10, volume: 1823, intensity: 7.8, recovery: 60, type: 'primary' },
            { id: 'epaules', name: '√âPAULES', normalized: 0.68, sets: 8, volume: 1456, intensity: 8.1, recovery: 70, type: 'secondary' },
            { id: 'bras', name: 'BRAS', normalized: 0.90, sets: 14, volume: 1987, intensity: 8.9, recovery: 55, type: 'primary' },
            { id: 'abs', name: 'ABS', normalized: 0.75, sets: 6, volume: 892, intensity: 7.5, recovery: 90, type: 'secondary' }
        ];
        
        const radar = new BioMetricsRadar('bioContainer', muscleData);
        console.log('‚úÖ BIO-METRICS initialis√© !');
        
        // ===== VOLUME LOAD GAUGE =====
        
        // Classe pour calculer le Volume Load depuis localStorage
        class VolumeLoadCalculator {
            constructor() {
                this.history = this.loadHistory();
            }
            
            loadHistory() {
                try {
                    const data = localStorage.getItem('workout_history');
                    return data ? JSON.parse(data) : [];
                } catch (error) {
                    console.error('‚ùå Erreur lecture historique:', error);
                    return [];
                }
            }
            
            getCurrentWeekNumber() {
                if (this.history.length === 0) return 1;
                const sortedHistory = [...this.history].sort((a, b) => {
                    return new Date(b.date) - new Date(a.date);
                });
                return sortedHistory[0].week || 1;
            }
            
            getCurrentWeekVolumeLoad() {
                const currentWeek = this.getCurrentWeekNumber();
                return this.getWeekVolumeLoad(currentWeek);
            }
            
            getWeekVolumeLoad(weekNumber) {
                const weekSessions = this.history.filter(session => {
                    return session.week === weekNumber && session.completed;
                });
                
                let totalVolume = 0;
                let totalSets = 0;
                let totalTUT = 0;
                
                weekSessions.forEach(session => {
                    if (session.stats && session.stats.total_volume) {
                        totalVolume += session.stats.total_volume;
                    }
                    if (session.exercises) {
                        session.exercises.forEach(exercise => {
                            if (exercise.sets) {
                                totalSets += exercise.sets || 0;
                            }
                        });
                    }
                    if (session.stats && session.stats.total_time_under_tension) {
                        totalTUT += session.stats.total_time_under_tension;
                    }
                });
                
                return {
                    weekNumber: weekNumber,
                    totalVolume: totalVolume,
                    totalSets: totalSets,
                    totalTUT: totalTUT,
                    sessionsCount: weekSessions.length,
                    inOptimalZone: totalVolume >= 15000 && totalVolume <= 22000
                };
            }
        }
        
        class VolumeLoadGauge {
            constructor(canvasId) {
                this.canvas = document.getElementById(canvasId);
                
                if (!this.canvas) {
                    console.error('‚ùå Canvas non trouv√©:', canvasId);
                    return;
                }
                
                this.ctx = this.canvas.getContext('2d', { alpha: true });
                
                // Constantes
                this.MAX_WEEKLY_VOLUME = 25000;
                this.ZONE_OPTIMAL_START = 15000;
                this.ZONE_OPTIMAL_END = 22000;
                
                this.init();
            }
            
            init() {
                this.setupCanvas();
                this.render();
            }
            
            setupCanvas() {
                const dpr = window.devicePixelRatio || 1;
                const rect = this.canvas.getBoundingClientRect();
                this.canvas.width = rect.width * dpr;
                this.canvas.height = rect.height * dpr;
                this.ctx.scale(dpr, dpr);
                this.rect = rect;
            }
            
            createCarbonPattern() {
                const patternCanvas = document.createElement('canvas');
                patternCanvas.width = 8;
                patternCanvas.height = 8;
                const pCtx = patternCanvas.getContext('2d');
                
                if (pCtx) {
                    pCtx.fillStyle = '#050505';
                    pCtx.fillRect(0, 0, 8, 8);
                    pCtx.fillStyle = '#1a1a1a';
                    pCtx.beginPath();
                    pCtx.moveTo(0, 8);
                    pCtx.lineTo(8, 0);
                    pCtx.lineTo(8, 8);
                    pCtx.fill();
                }
                
                return this.ctx.createPattern(patternCanvas, 'repeat');
            }
            
            toRad(deg) {
                return (deg * Math.PI) / 180;
            }
            
            render() {
                const carbonPattern = this.createCarbonPattern();
                
                // Calcule le Volume Load R√âEL depuis localStorage
                const calculator = new VolumeLoadCalculator();
                const weekStats = calculator.getCurrentWeekVolumeLoad();
                
                console.log('üìä Volume Load calcul√©:', weekStats);
                
                // Mettre √† jour les cartes stats
                const setsEl = document.getElementById('volumeSets');
                const tutEl = document.getElementById('volumeTUT');
                const volumeEl = document.getElementById('volumeTotal');
                const statusEl = document.getElementById('volumeStatus');
                
                if (setsEl) setsEl.textContent = weekStats.totalSets;
                if (tutEl) {
                    const minutes = Math.floor(weekStats.totalTUT / 60);
                    const seconds = weekStats.totalTUT % 60;
                    tutEl.textContent = minutes + ':' + String(seconds).padStart(2, '0');
                }
                if (volumeEl) volumeEl.textContent = (weekStats.totalVolume / 1000).toFixed(1) + 'k kg';
                if (statusEl) statusEl.textContent = weekStats.inOptimalZone ? '‚úÖ OPTIMAL' : '‚ö†Ô∏è AJUSTER';
                
                const val = Math.max(0, Math.min(this.MAX_WEEKLY_VOLUME, weekStats.totalVolume));
                const percent = val / this.MAX_WEEKLY_VOLUME;
                
                // Couleurs dynamiques selon la zone
                let hue = 30, sat = 100, light = 60; // Orange par d√©faut
                const inOptimalZone = val > this.ZONE_OPTIMAL_START && val < this.ZONE_OPTIMAL_END;
                
                if (inOptimalZone) {
                    hue = 150; // Vert
                } else if (val >= this.ZONE_OPTIMAL_END) {
                    hue = 340; // Rouge
                }
                
                const themeColor = `hsl(${hue}, ${sat}%, ${light}%)`;
                const glowColor = `hsl(${hue}, ${sat}%, 80%)`;
                
                const w = this.rect.width;
                const h = this.rect.height;
                const cx = w / 2;
                const cy = h / 2;
                const r = Math.min(w, h) * 0.42;
                
                this.ctx.clearRect(0, 0, w, h);
                
                // Rendu de la jauge
                this.drawChassis(cx, cy, r);
                this.drawCarbonBackground(cx, cy, r, carbonPattern);
                this.drawGraduations(cx, cy, r, percent, themeColor, glowColor);
                this.drawOptimalZone(cx, cy, r);
                this.drawLCD(cx, cy, r, themeColor, weekStats.totalVolume);
                this.drawNeedle(cx, cy, r, percent, themeColor);
                this.drawGlass(cx, cy, r);
            }
            
            drawChassis(cx, cy, r) {
                const ctx = this.ctx;
                ctx.save();
                ctx.shadowColor = 'rgba(0,0,0,0.8)';
                ctx.shadowBlur = 50;
                ctx.shadowOffsetY = 30;
                ctx.beginPath();
                ctx.arc(cx, cy, r * 1.12, 0, Math.PI * 2);
                ctx.fillStyle = '#000';
                ctx.fill();
                ctx.shadowColor = 'transparent';
                
                const bezelGrad = ctx.createLinearGradient(cx - r, cy - r, cx + r, cy + r);
                bezelGrad.addColorStop(0, '#334155');
                bezelGrad.addColorStop(0.2, '#94a3b8');
                bezelGrad.addColorStop(0.5, '#0f172a');
                bezelGrad.addColorStop(0.8, '#475569');
                bezelGrad.addColorStop(1, '#1e293b');
                
                ctx.beginPath();
                ctx.arc(cx, cy, r * 1.12, 0, Math.PI * 2);
                ctx.fillStyle = bezelGrad;
                ctx.fill();
                
                const dishGrad = ctx.createRadialGradient(cx, cy, r * 0.8, cx, cy, r * 1.05);
                dishGrad.addColorStop(0, '#000');
                dishGrad.addColorStop(0.8, '#0a0a0a');
                dishGrad.addColorStop(1, '#000');
                
                ctx.beginPath();
                ctx.arc(cx, cy, r * 1.05, 0, Math.PI * 2);
                ctx.fillStyle = dishGrad;
                ctx.fill();
                ctx.restore();
            }
            
            drawCarbonBackground(cx, cy, r, pattern) {
                const ctx = this.ctx;
                ctx.beginPath();
                ctx.arc(cx, cy, r * 1.0, 0, Math.PI * 2);
                if (pattern) {
                    ctx.fillStyle = pattern;
                    ctx.fill();
                }
                
                const innerShadow = ctx.createRadialGradient(cx, cy, r * 0.5, cx, cy, r * 1.0);
                innerShadow.addColorStop(0, 'rgba(0,0,0,0)');
                innerShadow.addColorStop(1, 'rgba(0,0,0,0.8)');
                ctx.fillStyle = innerShadow;
                ctx.fill();
            }
            
            drawGraduations(cx, cy, r, percent, themeColor, glowColor) {
                const ctx = this.ctx;
                const startAng = this.toRad(135);
                const endAng = this.toRad(405);
                const rangeAng = endAng - startAng;
                const ticksCount = 50;
                
                ctx.beginPath();
                ctx.arc(cx, cy, r * 0.85, startAng, endAng);
                ctx.lineWidth = 2;
                ctx.strokeStyle = '#1e293b';
                ctx.stroke();
                
                for (let i = 0; i <= ticksCount; i++) {
                    const t = i / ticksCount;
                    const angle = startAng + rangeAng * t;
                    const isMajor = i % 10 === 0;
                    const isLit = t <= percent;
                    
                    const tickLen = isMajor ? r * 0.12 : r * 0.06;
                    const outerR = r * 0.92;
                    const innerR = outerR - tickLen;
                    const x1 = cx + Math.cos(angle) * innerR;
                    const y1 = cy + Math.sin(angle) * innerR;
                    const x2 = cx + Math.cos(angle) * outerR;
                    const y2 = cy + Math.sin(angle) * outerR;
                    
                    ctx.beginPath();
                    ctx.moveTo(x1, y1);
                    ctx.lineTo(x2, y2);
                    
                    if (isLit) {
                        ctx.strokeStyle = isMajor ? glowColor : themeColor;
                        ctx.lineWidth = isMajor ? 3 : 1.5;
                        ctx.shadowColor = themeColor;
                        ctx.shadowBlur = isMajor ? 15 : 8;
                    } else {
                        ctx.strokeStyle = isMajor ? '#334155' : '#1e293b';
                        ctx.lineWidth = isMajor ? 2 : 1;
                        ctx.shadowBlur = 0;
                    }
                    ctx.stroke();
                    ctx.shadowBlur = 0;
                    
                    if (isMajor) {
                        const textR = r * 0.68;
                        const tx = cx + Math.cos(angle) * textR;
                        const ty = cy + Math.sin(angle) * textR;
                        ctx.font = `700 ${Math.max(8, r * 0.08)}px "Rajdhani", system-ui`;
                        ctx.fillStyle = isLit ? '#fff' : '#475569';
                        ctx.textAlign = 'center';
                        ctx.textBaseline = 'middle';
                        
                        if (isLit) {
                            ctx.shadowColor = themeColor;
                            ctx.shadowBlur = 10;
                        }
                        const displayVal = Math.round(t * this.MAX_WEEKLY_VOLUME / 1000);
                        ctx.fillText(displayVal + 'k', tx, ty);
                        ctx.shadowBlur = 0;
                    }
                }
            }
            
            drawOptimalZone(cx, cy, r) {
                const ctx = this.ctx;
                const startAng = this.toRad(135);
                const endAng = this.toRad(405);
                const rangeAng = endAng - startAng;
                
                const optStart = startAng + rangeAng * (this.ZONE_OPTIMAL_START / this.MAX_WEEKLY_VOLUME);
                const optEnd = startAng + rangeAng * (this.ZONE_OPTIMAL_END / this.MAX_WEEKLY_VOLUME);
                
                ctx.beginPath();
                ctx.arc(cx, cy, r * 0.95, optStart, optEnd);
                ctx.lineWidth = 5;
                ctx.strokeStyle = '#00ff9d';
                ctx.lineCap = 'round';
                ctx.globalAlpha = 0.7;
                ctx.stroke();
                ctx.globalAlpha = 1.0;
            }
            
            drawLCD(cx, cy, r, themeColor, weeklyVolume) {
                const ctx = this.ctx;
                const lcdR = r * 0.5;
                
                ctx.beginPath();
                ctx.arc(cx, cy, lcdR, 0, Math.PI * 2);
                ctx.fillStyle = '#000';
                ctx.fill();
                
                ctx.lineWidth = 1;
                ctx.strokeStyle = '#334155';
                ctx.stroke();
                
                const lensGrad = ctx.createLinearGradient(cx - lcdR, cy - lcdR, cx + lcdR, cy + lcdR);
                lensGrad.addColorStop(0, 'rgba(255,255,255,0.05)');
                lensGrad.addColorStop(0.5, 'transparent');
                lensGrad.addColorStop(1, 'rgba(255,255,255,0.02)');
                ctx.fillStyle = lensGrad;
                ctx.fill();
                
                ctx.textAlign = 'center';
                ctx.textBaseline = 'middle';
                ctx.font = `500 ${r * 0.065}px "Rajdhani", system-ui`;
                ctx.fillStyle = '#64748b';
                ctx.fillText("WEEKLY VOLUME", cx, cy - lcdR * 0.5);
                
                ctx.font = `700 ${r * 0.28}px "Rajdhani", system-ui`;
                ctx.fillStyle = '#fff';
                ctx.shadowColor = themeColor;
                ctx.shadowBlur = 25;
                
                const displayLoad = (weeklyVolume / 1000).toFixed(1);
                ctx.fillText(displayLoad + 'k', cx, cy + lcdR * 0.05);
                ctx.shadowBlur = 0;
                
                ctx.font = `400 ${r * 0.065}px system-ui`;
                ctx.fillStyle = themeColor;
                ctx.fillText("KG TOTAL", cx, cy + lcdR * 0.55);
            }
            
            drawNeedle(cx, cy, r, percent, themeColor) {
                const ctx = this.ctx;
                const startAng = this.toRad(135);
                const endAng = this.toRad(405);
                const rangeAng = endAng - startAng;
                
                const needleAngle = startAng + rangeAng * percent;
                const needleLen = r * 0.9;
                const needleW = r * 0.035;
                
                ctx.save();
                ctx.translate(cx, cy);
                ctx.rotate(needleAngle);
                ctx.shadowColor = themeColor;
                ctx.shadowBlur = 30;
                
                ctx.beginPath();
                ctx.moveTo(0, -needleW);
                ctx.lineTo(needleLen, 0);
                ctx.lineTo(0, needleW);
                ctx.lineTo(-needleW * 2, 0);
                ctx.closePath();
                
                const needleGrad = ctx.createLinearGradient(-needleW * 2, 0, needleLen, 0);
                needleGrad.addColorStop(0, '#fff');
                needleGrad.addColorStop(0.2, themeColor);
                needleGrad.addColorStop(1, themeColor);
                
                ctx.fillStyle = needleGrad;
                ctx.fill();
                ctx.restore();
                
                ctx.beginPath();
                ctx.arc(cx, cy, r * 0.05, 0, Math.PI * 2);
                ctx.fillStyle = '#e2e8f0';
                ctx.shadowColor = '#000';
                ctx.shadowBlur = 5;
                ctx.fill();
            }
            
            drawGlass(cx, cy, r) {
                const ctx = this.ctx;
                
                const glassReflect = ctx.createLinearGradient(cx - r, cy - r * 1.5, cx + r, cy + r);
                glassReflect.addColorStop(0, 'rgba(255,255,255,0.15)');
                glassReflect.addColorStop(0.3, 'rgba(255,255,255,0.05)');
                glassReflect.addColorStop(0.31, 'rgba(255,255,255,0)');
                glassReflect.addColorStop(1, 'rgba(255,255,255,0)');
                
                ctx.beginPath();
                ctx.arc(cx, cy, r * 1.08, 0, Math.PI * 2);
                ctx.fillStyle = glassReflect;
                ctx.fill();
            }
        }
        
        // Initialiser VOLUME LOAD
        const volumeGauge = new VolumeLoadGauge('volumeGaugeCanvas');
        console.log('‚úÖ VOLUME LOAD initialis√© !');
    </script>
</body>
</html>
